/*
 * Nearly traditional build with separate "generated" source set, but with resources redirected
 * to main classes in order to support Hibernate auto-scan even in SE (with persistence.xml and
 * entity classes in different classpath components it does not work).
 *
 * All of the Gradle builds from this module suffer a problem in Intellij IDEA when running with
 * Hibernate expecting that auto-scan finds classes and resources in a single classpath component.
 * IntelliJ IDEA by default compiles to its own directories (out) and keeps classes separate from
 * resources. When the same module is imported as Maven project, IDEA uses target/classes where
 * both resources and classes are under one component. To get the same behaviour with IDEA we need
 * to enable "File | Settings | Build, Execution, Deployment | Build Tools | Gradle | Runner =>
 * Delegate IDE build/run actions to gradle". See also:
 *
 * https://stackoverflow.com/q/45174989/658826
 * https://youtrack.jetbrains.com/issue/IDEA-175172
 *
 * With this build delegation run configuration in IDEA seem to work flawlessly (IDEA 2017.2.3).
 */
plugins {
  id 'java'
}

repositories {
  jcenter()
}

configurations {
  querydslApt
  jpaMetamodelApt
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

tasks.withType(JavaCompile) {
  options.encoding = 'UTF-8'
}

ext {
  querydslVersion = '4.1.4'
  hibernateVersion = '5.2.2.Final'
  eclipseLinkVersion = '2.6.2'
  h2Version = '1.4.190'
  logbackVersion = '1.2.3'
  testNgVersion = '6.11'
}

dependencies {
  compileOnly 'javax:javaee-api:7.0'
  compile "com.querydsl:querydsl-jpa:$querydslVersion"
  compile "org.hibernate:hibernate-entitymanager:$hibernateVersion"
  compile "org.eclipse.persistence:org.eclipse.persistence.jpa:$eclipseLinkVersion"
  compile "com.h2database:h2:$h2Version"
  compile "ch.qos.logback:logback-classic:$logbackVersion"

  testCompile "org.testng:testng:$testNgVersion"

  querydslApt "com.querydsl:querydsl-apt:$querydslVersion"
  jpaMetamodelApt "org.eclipse.persistence:org.eclipse.persistence.jpa.modelgen.processor:$eclipseLinkVersion"
}

sourceSets {
  // these three lines is the only difference against querydsl-traditional.build
  main {
    output.resourcesDir = "$buildDir/classes/java/main"
  }
  generated {
    java {
      srcDirs = ["$buildDir/generated-src"]
    }
  }
  test {
    // This is required for tests to "see" generated classes as well
    runtimeClasspath += generated.output
  }
}

task generateQuerydsl(type: JavaCompile, group: 'build', description: 'Generates the QueryDSL query types') {
  source = sourceSets.main.java
  classpath = configurations.compile + configurations.querydslApt
  options.compilerArgs = [
    '-proc:only',
    '-processor', 'com.querydsl.apt.jpa.JPAAnnotationProcessor'
  ]
  destinationDir = sourceSets.generated.java.srcDirs.iterator().next()
}

task generateJpaMetamodel(type: JavaCompile, group: 'build', description: 'Generates metamodel for JPA Criteria (not QueryDSL)') {
  source = sourceSets.main.java
  classpath = configurations.compile + configurations.jpaMetamodelApt
  options.compilerArgs = [
    '-proc:only',
    '-processor', 'org.eclipse.persistence.internal.jpa.modelgen.CanonicalModelProcessor',
    '-Aeclipselink.persistencexml=src/main/resources/META-INF/persistence.xml',
    '-Aeclipselink.persistenceunits=demo-el'
  ]
  destinationDir = sourceSets.generated.java.srcDirs.iterator().next()
}

compileJava {
  dependsOn generateQuerydsl
  dependsOn generateJpaMetamodel
  source generateQuerydsl.destinationDir
  source generateJpaMetamodel.destinationDir
}

compileGeneratedJava {
  dependsOn generateQuerydsl
  dependsOn generateJpaMetamodel
  options.warnings = false
  classpath += sourceSets.main.runtimeClasspath
}

test {
  useTestNG()
}