# Avoid N+1 select {#ch-avoid-n-plus-1}

While performance tuning is not the main goal of this book we should follow some elementary
performance common sense. If we can avoid an unnecessary query we should do so. With ORM/JPA
we can generate a lot of needless queries without even realizing. In this chapter we will cover
the most pronounced problem called *N+1 select*.

{icon=book}
G> ### SQL Performance Explained
G>
G> I can highly recommend this incredible book ([[SQLPE](#bib-sqlpe)]) which explains indexes,
G> joins, execution plans and many other aspects of queries (including data modification) in just
G> under 200 pages. This not only is a true gem in this area, it can be also obtained as PDF from
G> [its site](http://sql-performance-explained.com) for 10 Eur or so. It mentions N+1 problem
G> as well.


## Anatomy of N+1 select

I'd prefer to call this problem 1+N because it mostly starts with one query that returns N rows
and induces up to N additional queries. While addition is commutative, hence 1+N is the same like
N+1, I'll stick to *N+1* as usually used in literature. The typical scenarios when the N+1 problem
appears are:

* Query for N entities that have eager *to-one* relationship -- or more of them -- and the provider
is not smart enough to use joins.
* Query for N entities that have eager *to-many* relationship and the provider is either not smart
enough to use the join (again) or it is not possible to use it for other reasons like pagination.
We will cover paginating of entities with *to-many* [later in this chapter](#to-many-paginating).
* Query for N entities with lazy relationship that is triggered later, e.g. in the view as
usual with open-session-in-view (OSIV) pattern.

There are probably more scenarios, but these are the most typical ones. First let's look at the
eager examples.


## Eager *to-one* without joins

If you recall our [simple example with `@ManyToOne`](#many-to-one-simple-example) from the chapter
[Troubles with *to-one* relationships](#ch-to-one-troubles) you know that *to-one* relationships
may trigger additional fetching. These may result in DB queries or they can be found in the
cache -- depends on your setting -- and this all must be taken into consideration.

For the next sections let's use the following data for dogs and their owners:

{title="Content of **Owner** table", width="narrow"}
| id | name |
|----|------|
| 1 | Adam |
| 2 | Charlie |
| 3 | Joe |
| 4 | Mike |

{title="Content of **Dog** table", width="narrow"}
| id | name | owner_id |
|----|------|-----|----------|
| 1 | Alan | 1 (Adam) |
| 2 | Beastie | 1 (Adam) |
| 3 | Cessna | 1 (Adam) |
| 4 | Rex | 3 (Joe) |
| 5 | Lessie | 4 (Mike) |
| 6 | Dunco | 4 (Mike) |
| 7 | Goro | `NULL` |

Our mapping for the `Dog` looks like this:

~~~
@Entity
public class Dog {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Integer id;

  private String name;

  @ManyToOne(fetch = FetchType.EAGER)
  @JoinColumn(name = "owner_id")
  private Owner owner;
~~~

And for the `Owner`:

~~~
@Entity
public class Owner implements Serializable {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Integer id;

  private String name;

  @OneToMany(mappedBy = "owner")
  private Set<Dog> dogs;
~~~

Now let's list all the dogs with this code:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .fetch();
~~~

We get seven dogs for three different owners (one dog is not owned) but what happened on the SQL
level? Both Hibernate and EclipseLink do something like this (output from EclipseLink):

{lang=sql}
~~~
SELECT ID, NAME, OWNER_ID FROM DOG
SELECT ID, NAME FROM OWNER WHERE (ID = 1)
SELECT ID, NAME FROM OWNER WHERE (ID = 3)
SELECT ID, NAME FROM OWNER WHERE (ID = 4)
~~~

That classifies as N+1 problem, although the N may be lower than the count of
selected rows thanks to the persistence context. JPA providers may be persuaded to use `JOIN`
to fetch the information but this is beyond the current version of JPA specification. EclipseLink
offers `@JoinFetch(JoinFetchType.OUTER)` and Hibernate has `@Fetch(FetchMode.JOIN)` (also uses
outer select). In a related [demo](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/n-plus-one-problem/src/test/java/tests/ManyToOneEagerNPlusOneProblem.java)
I tried both and to my surprise EclipseLink obeyed but Hibernate did not -- which went against my
previous experiences that Hibernate tries to optimize queries better in general.

Now, what if we don't need any data for owner? You may try to use lazy fetch for the data you
don't need *if you know you can rely on `LAZY`* or try some other technique described in
[Troubles with *to-one* relationships](#ch-to-one-troubles). Here *entity views* come to mind, but
projections may be even better.

Anytime I wanted to load dogs with their owners I'd go for explicit `JOIN`. Let's see how to
do that properly. Even though we don't use the owners in select it is not sufficient construct
query like this:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .leftJoin(QDog.dog.owner)
  .fetch();
~~~

This results in an invalid JPQL query:

{lang=sql}
~~~
select dog
from Dog dog
  left join dog.owner
~~~

While this runs on Hibernate, it fails on EclipseLink with a syntax error: *An identification
variable must be defined for a JOIN expression.* This, indeed, is necessary according to the
specification and we must add an alias like so:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .leftJoin(QDog.dog.owner, QOwner.owner)
  .fetch();
~~~

This results in a valid JPQL query:

{lang=sql}
~~~
select dog
from Dog dog
  left join dog.owner as owner
~~~

But without using it in `select` -- which we don't want because we don't want the list of
`Tuple`s -- we end up with a query with our join, but the data for owners is still not fetched
and N additional queries are executed just like before. Had we used it in the select it would be
fetched, of course.

The right way to do it if we insist on the result typed as `List<Dog>` is this:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .leftJoin(QDog.dog.owner).fetchJoin()
  .fetch();
~~~

This results in a valid and correct JPQL query:

{lang=sql}
~~~
select dog
from Dog dog
  left join fetch dog.owner
~~~

Notice we haven't used alias this time and looking at BNF
([Backusâ€“Naur form](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)) notation from
[[JPspec](#bib-jpspec)], section *4.4.5 Joins* I believe `identification_variable` is allowed
only for `join` and not for `fetch_join` rules. Nonetheless, both Hibernate and EclipseLink
tolerate this.

W> Note that `JOIN` query doesn't take advantage of any results in entity cache because now you
W> don't access them by ID. But at least we say exactly what we want. We still have to mind any
W> "downstream" *to-one* relationships on the joined entity. For the most precise and efficient
W> results I can, again, only recommend using projections, albeit being least ORM-ish. This means
W> using the data you need in the `SELECT` clause and skipping `FETCH` clauses in the resulting
W> JPQL.


## Eager *to-many* relationships

Using `EAGER` on collections by default is rather risky. I'd personally not use it and use explicit
joins when needed instead. In our [example](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/n-plus-one-problem/src/test/java/tests/OneToManyEagerNPlusOneProblem.java)
we will use `OwnerEager` entity that uses the same table like `Owner` (hence the same prepared
data) but maps `dogs` collection as:

~~~
@OneToMany(mappedBy = "owner", fetch = FetchType.EAGER)
private Set<DogEager> dogs;
~~~

Now we run the following code:

~~~
List<OwnerEager> owners = new JPAQuery<>(em)
  .select(QOwnerEager.ownerEager)
  .from(QOwnerEager.ownerEager)
  .fetch();
System.out.println("\nowners = " + owners);
for (OwnerEager owner : owners) {
  System.out.println(owner.getName() + "'s dogs = " + owner.getDogs());
}
~~~

SQL produced at the point `fetch()` is executed is (output from EclipseLink, Hibernate is similar):

{lang=sql}
~~~
SELECT ID, NAME FROM Owner
SELECT ID, NAME, owner_id FROM Dog WHERE (owner_id = ?)
SELECT ID, NAME, owner_id FROM Dog WHERE (owner_id = ?)
SELECT ID, NAME, owner_id FROM Dog WHERE (owner_id = ?)
SELECT ID, NAME, owner_id FROM Dog WHERE (owner_id = ?)
~~~

And output of the subsequent print statements (manually wrapped):

{lang=text}
~~~
owners = [Person{id=1, name=Adam}, Person{id=2, name=Charlie},
 Person{id=3, name=Joe}, Person{id=4, name=Mike}]
Adam's dogs = [Dog{id=1, name='Alan', owner.id=1}, Dog{id=2,
 name='Beastie', owner.id=1}, Dog{id=3, name='Cessna', owner.id=1}]
Charlie's dogs = []
Joe's dogs = [Dog{id=4, name='Rex', owner.id=3}]
Mike's dogs = [Dog{id=5, name='Lessie', owner.id=4},
 Dog{id=6, name='Dunco', owner.id=4}]
~~~

Everything is OK, except it can all be done in a single query. Had we added a single fetch join
line in the query we would have had it in a single go:

~~~
List<OwnerEager> owners = new JPAQuery<>(em)
  .select(QOwnerEager.ownerEager)
  .from(QOwnerEager.ownerEager)
  .leftJoin(QOwnerEager.ownerEager.dogs).fetchJoin()
  .fetch();
~~~

Join reaches for the data -- notice we have to use `leftJoin` if the collection may be empty -- and
`fetchJoin` takes care of putting them in the collection. This is probably the best what we can
explicitly do with eager collection mapping in place. Resulting SQL (here EclipseLink):

{lang=sql}
~~~
SELECT t1.ID, t1.NAME, t0.ID, t0.NAME, t0.owner_id
 FROM {oj Owner t1 LEFT OUTER JOIN Dog t0 ON (t0.owner_id = t1.ID)}
~~~

W> Problem with joins across *to-many* relationship is that they change the "shape" of the
W> resulting relation (or "table" if you will) in *both* directions and many lines of the driving
W> table (owners in our examples) can be repeated. This makes simple pagination with `LIMIT` and
W> `OFFSET` clauses impossible.
W>
W> From the correctness point this is not a problem for non-join query that first paginates on
W> owners properly and then loads the dogs for N owners on the page. But this still is a
W> performance problem and we will tackle it in the section [Paginating with
W> *to-many*](#to-many-paginating) lower.

In general, if eager fetch on collection is not executed using a join on the background it is not
worth it. We can get the same N+1 behavior with lazy loads although it may require some explicit
code to actually fetch the collection when you want -- e.g. in the service layer instead of later
in presentation layer with persistence context already not available.

There is one crucial difference between N+1 across *to-one* and *to-many* relationships. In case
of *to-one* JPA provider may utilize entity cache as the ID of the needed entity is already
available. In case of *to-many*, on the other hand, we have to execute actual select. This may
use query cache -- but setting that one appropriately is definitely more tricky than the entity
cache. Without caches this difference is blurred away and the only difference is that for *to-one*
we're accessing rows in DB by its primary key, while for *to-many* we're using the foreign key. PK
is virtually always indexed, FK not necessarily so -- but I guess it should be when we're using
this access pattern.

Perhaps there are some settings or custom annotations that make JPA provider perform the join, but
it must be smart enough not to use it when limit/offset is in play. As this capability is not
available in JPA -- and because I believe eager collections are even worse than eager to-one --
we will not delve into it any more.


## Lazy relationships triggered later

Lazy fetch is a reasonable default for mapping collections -- and it is default according to the
specification. Because collection can be implemented in a custom way all JPA providers offer lazy
behavior without the need for any bytecode magic.



I> EclipseLink and `toString()` -- is it a "business" method or not? We're used to
I> `toString` output as defined in `AbstractCollection`, but `Set` does not imply any particular
I> format.


## Paginating with *to-many* {#to-many-paginating}

I mentioned previously that we [can't escape SQL](#cant-escape-sql) underneath.

TODO bigger example, some table picture, then solution
TODO mention ORDER, of course :-)

Possible pure SQL solution where we only paginate over the table we need to -- but this requires
subquery in from:

~~~

(6 rows, 0 ms)

-- good
select * from (select * from owner limit 2 offset 2) o left join dog d on o.id=d.owner_id ;
ID  	NAME  	ID  	NAME  	BREED  	OWNER_ID
3	Joe	6	Rex	null	3
4	Mike	7	Lessie	null	4
4	Mike	8	Dunco	null	4
(3 rows, 0 ms)

-- wrong
select * from owner o left join dog d on o.id=d.owner_id limit 2 offset 2;
ID  	NAME  	ID  	NAME  	BREED  	OWNER_ID
1	Adam	5	Cessna	null	1
2	Charlie	null	null	null	null
~~~
