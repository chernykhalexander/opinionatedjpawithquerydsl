# Avoid N+1 select {#ch-avoid-n-plus-1}

While performance tuning is not the main goal of this book we should follow some elementary
performance common sense. If we can avoid an unnecessary query we should do so. With ORM/JPA
we can generate a lot of needless queries without even realizing. In this chapter we will cover
the most pronounced problem called *N+1 select*.

{icon=book}
G> ### SQL Performance Explained
G>
G> I can highly recommend this incredible book ([[SQLPE](#bib-sqlpe)]) which explains indexes,
G> joins, execution plans and many other aspects of queries (including data modification) in just
G> under 200 pages. This not only is a true gem in this area, it can be also obtained as PDF from
G> [its site](http://sql-performance-explained.com) for 10 Eur or so. It mentions N+1 problem
G> as well.


## Anatomy of N+1 select

I'd prefer to call this problem 1+N because it mostly starts with one query that returns N rows
and induces N additional queries. While addition is commutative -- hence 1+N is the same like N+1
-- I'll stick to *N+1* as usually used in literature. The typical scenarios when the N+1 problem
appears are:

* Query for N entities that have eager *to-one* relationship -- or more of them -- and the provider
is not smart enough to use joins.
* Query for N entities that have eager *to-many* relationship and the provider is either not smart
enough to use the join (again) or it is not possible to use it for other reasons like pagination.
We will cover paginating of entities with *to-many* [later in this chapter](#to-many-paginating).
* Query for N entities later with lazy relationship that is triggered later, e.g. in the view as
usual with open-session-in-view (OSIV) pattern.

There are probably more scenarios, but these are the most typical ones. First let's look at the
eager examples.


### Eager *to-one* without joins

If you recall our [simple example with `@ManyToOne`](#many-to-one-simple-example) from the chapter
[Troubles with *to-one* relationships](#ch-to-one-troubles) you know that *to-one* relationships
may trigger additional fetching. These may result in DB queries or they can be found in the
cache -- depends on your setting -- and this all must be taken into consideration.

For the next sections let's use the following data for dogs and their owners:

{title="Content of **Owner** table", width="narrow"}
| id | name |
|----|------|
| 1 | Adam |
| 2 | Charlie |
| 3 | Joe |
| 4 | Mike |

{title="Content of **Dog** table", width="narrow"}
| id | name | owner_id |
|----|------|-----|----------|
| 1 | Alan | 1 (Adam) |
| 2 | Beastie | 1 (Adam) |
| 3 | Cessna | 1 (Adam) |
| 4 | Rex | 3 (Joe) |
| 5 | Lessie | 4 (Mike) |
| 6 | Dunco | 4 (Mike) |
| 7 | Goro | `NULL` |

Our mapping for the `Dog` looks like this:

~~~
@Entity
public class Dog {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Integer id;

  private String name;

  @ManyToOne(fetch = FetchType.EAGER)
  @JoinColumn(name = "owner_id")
  private Owner owner;
~~~

And for the `Owner`:

~~~
@Entity
public class Owner implements Serializable {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Integer id;

  private String name;

  @OneToMany(mappedBy = "owner")
  private Set<Dog> dogs;
~~~

Now let's list all the dogs with this code:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .fetch();
~~~

We get seven dogs for three different owners (one dog is not owned) but what happened on the SQL
level? Both Hibernate and EclipseLink do something like this (output from EclipseLink):

~~~
SELECT ID, NAME, OWNER_ID FROM DOG
SELECT ID, NAME FROM OWNER WHERE (ID = 1)
SELECT ID, NAME FROM OWNER WHERE (ID = 3)
SELECT ID, NAME FROM OWNER WHERE (ID = 4)
~~~

That classifies as N+1 problem, although the N may be lower than the count of
selected rows thanks to the persistence context. JPA providers may be persuaded to use `JOIN`
to fetch the information but this is beyond the current version of JPA specification. EclipseLink
offers `@JoinFetch(JoinFetchType.OUTER)` and Hibernate has `@Fetch(FetchMode.JOIN)` (also uses
outer select). In a related [demo](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/querydsl-basic/src/test/java/tests/Pagination.java)
I tried both and to my surprise EclipseLink obeyed but Hibernate did not -- which went against my
previous experiences that Hibernate tries to optimize queries better in general.

Now, what if we don't need any data for owner? You may try to use lazy fetch for the data you
don't need *if you know you can rely on `LAZY`* or try some other technique described in
[Troubles with *to-one* relationships](#ch-to-one-troubles). Here *entity views* come to mind, but
projections may be even better.

Anytime I wanted to load dogs with their owners I'd go for explicit `JOIN`. Let's see how to
do that properly. Even though we don't use the owners in select it is not sufficient construct
query like this:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .leftJoin(QDog.dog.owner)
  .fetch();
~~~

This results in an invalid JPQL query:

~~~
select dog
from Dog dog
  left join dog.owner
~~~

While this runs on Hibernate, it fails on EclipseLink with a syntax error: *An identification
variable must be defined for a JOIN expression.* This, indeed, is necessary according to the
specification and we must add an alias like so:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .leftJoin(QDog.dog.owner, QOwner.owner)
  .fetch();
~~~

This results in a valid JPQL query:

~~~
select dog
from Dog dog
  left join dog.owner as owner
~~~

But without using it in `select` -- which we don't want because we don't want the list of
`Tuple`s -- we end up with a query with our join, but the data for owners is still not fetched
and N additional queries are executed just like before. Had we used it in the select it would be
fetched, of course.

The right way to do it if we insist on the result typed as `List<Dog>` is this:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .leftJoin(QDog.dog.owner).fetchJoin()
  .fetch();
~~~

This results in a valid and correct JPQL query:

~~~
select dog
from Dog dog
  left join fetch dog.owner
~~~

Notice we haven't used alias this time and looking at BNF
((Backusâ€“Naur form)[https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)) notation from
[[JPspec](#bib-jpspec)], section *4.4.5 Joins* I believe `identification_variable` is allowed
only for `join` and not for `fetch_join` rules. Nonetheless, both Hibernate and EclipseLink
tolerate this.

W> Note that `JOIN` query doesn't take advantage of any results in entity cache because now you
W> don't access them by ID. But at least we say exactly what we want. We still have to mind any
W> "downstream" *to-one* relationships on the joined entity. For the most precise and efficient
W> results I can, again, only recommend using projections, albeit being least ORM-ish. This means
W> using the data you need in the `SELECT` clause and skipping `FETCH` clauses in the resulting
W> JPQL.


### Eager *to-many* relationships

TODO: where does this make sense?


### Lazy relationships triggered later

TODO


## Paginating with *to-many* {#to-many-paginating}

I mentioned previously that we [can't escape SQL](#cant-escape-sql) underneath.

TODO bigger example, some table picture, then solution

Possible pure SQL solution where we only paginate over the table we need to -- but this requires
subquery in from:

~~~

(6 rows, 0 ms)

-- good
select * from (select * from owner limit 2 offset 2) o left join dog d on o.id=d.owner_id ;
ID  	NAME  	ID  	NAME  	BREED  	OWNER_ID
3	Joe	6	Rex	null	3
4	Mike	7	Lessie	null	4
4	Mike	8	Dunco	null	4
(3 rows, 0 ms)

-- wrong
select * from owner o left join dog d on o.id=d.owner_id limit 2 offset 2;
ID  	NAME  	ID  	NAME  	BREED  	OWNER_ID
1	Adam	5	Cessna	null	1
2	Charlie	null	null	null	null
~~~

TODO: what happens with relationships marked as EAGER?