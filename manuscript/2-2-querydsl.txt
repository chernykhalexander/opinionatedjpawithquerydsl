# No further step without Querydsl {#ch-querydls}

I do realize I'm breaking a flow of the book a little bit, but since I've been introduced to this
neat library I became a huge fan and I never looked back. It doesn't affect JPA itself because
it sits above it but in your code it virtually replaces both JPQL and especially Criteria API.

To put it simply, [Querydsl](http://www.querydsl.com) is a library that -- from programmer's
perspective -- works like a more expressive and readable version of *Java Persistence Criteria
API*. Internally it first generates JPQL and the rest from there is handled by the JPA provider.
Querydsl can actually talk to many more back-ends: SQL, Hibernate directly and others, but we
will focus on Querydsl over JPA here. To use it goes in these steps:

* declare the dependency for Querydsl library and to its annotation processor,
* add a step in your build to generate metamodel classes,
* and write queries happily in sort of criteria-like way.

But Criteria API also lets you use generated metamodel, so what's the deal? Why would I introduce
non-standard third-party library when it does not provide any additional advantage? If you even
hate this idea, then you probably can stop reading this book -- or you can translate all my
Querydsl code into JPQL or Criteria yourself, which is perfectly doable, of course! Querydsl does
not disrupt the stack under it, it is "just" slapped over the JPA to make it more convenient.

I> Appendix [Project example](#app-project-example) shows the details needed in your build files
I> to set up annotation processor for Querydsl.

Querydsl brings in a [domain-specific language](https://en.wikipedia.org/wiki/Domain-specific_language)
(DSL) in the form of its fluent API. It happens to be so-called internal DSL because it's still
embedded in Java, it's not different language per se. This fluent API is more concise, readable and
convenient than Criteria API.

DSL is a language of some specific domain -- in this case it's a query language very close to JPQL
or SQL. It builds on a generated metamodel a lot. API of this metamodel is well-though and takes
type-safety to a higher level compared with Criteria API. This not only gives us compile-time
checks for our queries, but also offers even better auto-completion in IDEs.


## Simple example with Querydsl

Let's be concrete now -- but also very simple. We have a class `Dog`, each dog has a `name`
and we will query by this `name`. Assuming we got hold of `EntityManager` (variable `em`) the code
goes like this:

{title="Querydsl simple example", lang=java}
~~~
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.name.like("Re%"))
//.where(QDog.dog.name.startsWith("Re")) // alternative
  .fetch();
~~~

Both `where` alternatives produce the same result in this case, but `startsWith` may communicate
the intention better, unless you go for `like("%any%")` in which case `contains` would be better.
If you are provided input values for `like`, leave it. If you can tell from the logic that more
specific name for the operation is better, go for it.

This is a very subtle thing, but we can see that this DSL contains variations that can communicate
our intention more clearly. Criteria API sticks to `like` only, because that is its internal model.
Other thing is how beautifully the whole query flows. In version 4.x the fluent API got even closer
to JPQL/SQL semantics, it starts with `select` (what) and ends with `fetch` which is a mere
signal to deliver the results. As with any other fluent API, you need a terminal operation.
In previous versions you would have no `select` because it was included in a terminal operation,
e.g. `list(QDog.dog)`. Newer version is one line longer, but closer to the target domain
of query languages. Advanced chapter has a dedicated section on [differences between
versions 3 and 4](#querydsl3vs4).

D> And yes, I wrap the code like this even in IDE where I could afford 160 characters or more.
D> That, however, is completely different topic and there are people that can explain it [much
D> better](http://www.infoq.com/presentations/7-ineffective-coding-habits).
D> The whole linked presentation is good (and fun!), but at least watch the part from 17m25s.


## Comparison with Criteria API

Both Querydsl and Criteria API are natural fit for dynamic query creation. Doing this with JPQL
is rather painful. Imagine a search form with separate fields for a person
entity, so you can search by name, address, date of birth from--to, etc. We don't want to add
the search condition when the respective input field is empty. If you have done this before
with any form of query string concatenation then you probably know the pain. In extreme cases
of plain JDBC with prepared statement you even have to write all the `if`s twice -- first to add
`where` condition (or `and` for any next one) and second to set parameters. Technically you can
embed the parameter values into the query, but let's help the infamous
[injection](https://en.wikipedia.org/wiki/SQL_injection) vulnerability get off the top of the
[OWASP Top 10 list](https://www.owasp.org/index.php/Top_10_2013-Top_10).

T> If you ever need to construct JDBC statements again -- and there are cases when JPA is not
T> enough, like streaming a really long list of results -- you definitely want to use something like Spring's
T> [`JdbcTemplate`](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-JdbcTemplate).
T> This still leaves putting the query together to you, but allows you to add each parameter
T> value at the time when you add the where part. And also takes away many low-level JDBC concerns.
T>
T> By the way: Do you remember *JPA 1.0*? It didn't have any Criteria API!

Let's see how query for our dogs looks like with Criteria API -- again starting from `em`:

{title="Criteria API simple example", lang=java}
~~~
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Dog> query = cb.createQuery(Dog.class);
Root<Dog> dog = query.from(Dog.class);
query.select(dog)
  // this is the only place where we can use metamodel in this example
  .where(cb.like(dog.get(Dog_.name), "Re%"));
  // without metamodel it would be:
//.where(cb.like(dog.<String>get("name"), "Re%"));
List<Dog> dogs = em.createQuery(query)
  .getResultList();
~~~

Let's observe now:

* First you need to get `CriteriaBuilder` from existing `em`. You might "cache" this into
a field but it may not play well with EE component model, so I'd rather get it before using.
This should not be heavy operation, in most cases entity manager holds this builder already
and merely gives it to you (hence `get` and not `new` or `create`).
* Then you create an instance of `CriteriaQuery`.
* From this you need to get a `Root` object representing content of a `from` clause.
* Then you use the `query` in a nearly-fluent fashion. Version with metamodel is presented
with alternative without it in the comment.
* Finally, you use `em` again to get a `TypedQuery` based on the `CriteriaQuery` and we ask it
for results.

D> Creators of JPA decided not to go with fluent API and it shows. If you read this for a while
D> you'll get the meaning, especially when you're used to it, but our mind needs to stretch more
D> mental "muscles" to get it compared with the Querydsl version. Clearly, signal-to-noise ratio
D> is much lower too.

While in case of Criteria API you don't need to generate metamodel from the entity classes,
in Querydsl this is not optional. But using metamodel in Criteria API is advantageous anyway
so the need to generate the metamodel for Querydsl using annotation processor can hardly be
considered a drawback. It can be easily integrated with Maven or other build as demonstrated
in the [companion sources](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/querydsl-basic/pom.xml)
to this book or [documented](http://www.querydsl.com/static/querydsl/4.0.7/reference/html/ch02.html#d0e127)
on Querydsl site.

For another comparison of Querydsl and Criteria API, you can also check the
[original blog post](http://blog.mysema.com/2010/04/querydsl-as-alternative-to-jpa-2.html)
from 2010. Querydsl was much younger then (version 1.x) but the difference was striking already.


## Comparison with JPQL

Comparing Querydsl with Criteria API was rather easy as they are in the same ballpark. Querydsl,
however, with its fluency can be compared to JPQL as well. After all JPQL is non-Java DSL,
even though it typically is embedded in Java code. Let's see JPQL in action first to finish
our side-by-side comparisons:

{title="JPQL simple example", lang=java}
~~~
List<Dog> dogs = em.createQuery(
  "select d from Dog d where d.name like :name", Dog.class)
  .setParameter("name", "Re%")
  .getResultList();
~~~

This is it! Straight to the point, and you can even call it fluent! Probably the best we can do
with Querydsl is adding one line to introduce shorter "alias" like this:

{title="Querydsl simple example with alias", lang=java}
~~~
QDog d = new QDog("d1");
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(d)
  .from(d)
  .where(d.name.startsWith("Re"))
  .fetch();
~~~

Using aliases is very handy especially for longer and/or more complicated queries. We could
use `QDog.dog` as the value, or here I introduced new query variable and named it `d1`. This
name will appear in generated JPQL that looks a little bit different from the JPQL in example
above:

~~~
select d1 from Dog d1 where d1.name like ?1 escape '!'
~~~

There is a subtle difference in how Querydsl generates `like` clause -- which, by the way, is fully
customizable using Querydsl templates. But you can see that alias appears in JPQL, although neither
EclipseLink nor Hibernate bother to translate it to the generated SQL for your convenience.

Now, if we compare both code snippets above (alias creation included) we get a surprising result --
there are more characters in the JPQL version! Although it's just a nit-picking (line/char up or
down), it's clear that Querydsl can express JPQL extremely well (especially in 4.x version)
and at the same time it allows for easy dynamic query creation.

You may ask about named queries. Here I admit right away, that Querydsl necessarily introduces
overhead (see the next section on disadvantages), but when it comes to query reuse from
programmer's perspective Querydsl offers so called detached queries. While these are not covered
in their reference manual (as of March 2016), we will talk [more about
them](#querydsl-detached-queries) in a chapter about [advanced Querydsl
topics](#ch-advanced-querydsl).


## What about the cons? {#querydsl-cons}

Before we move to other Querydsl topics I'd go over its disadvantages.
For one, you're definitely adding some overhead. I don't know exactly how big, maybe with the SQL
backend (using JDBC directly) it would be more pronounced because ORM itself is big overhead
anyway. In any case, there is object graph of the query in the memory before it is serialized into
JPQL -- and from there it's on the same baseline like using JPA directly.

This performance factor obviously is not a big deal for many Querydsl users (some of them are
really big names), it mostly does not add too much to the SQL execution itself, but in any case --
if you are interested you have to measure it yourself. Also realize that without Querydsl you
either have to mess with JPQL strings before you have the complete dynamic WHERE part or you should
compare it with Criteria API which does not have to go through JPQL, but also creates some object
graph in the memory (richer or not? depends).

Documentation, while good, is definitely not complete. For instance, detached queries are not
mentioned in their [Querydsl Reference Guide](http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/)
and there is much more you need to find out yourself. You'll need to find your own best practices,
probably, but it is not that difficult with Querydsl. Based (not only) on my own experience, it
is literally joy to work with Querydsl and explore what it can provide -- for me it worked like
this from day zero. It's also very easy to find responses on the
[StackOverflow](http://stackoverflow.com/questions/tagged/querydsl) or their
[mailing-list](https://groups.google.com/forum/#!forum/querydsl), very often provided directly
by Querydsl developers. This makes any lack of documentation easy to overcome.

Finally, you're adding another dependency to the project, which may be a problem for some. For the
teams I worked with it was well compensated by the code clarity Querydsl gave us.


## Be explicit with aliases

With attribute paths at our disposal it is easy to require some data without explicitly using
joins. Let's consider the following entity chain:

![Class diagram of our entity model](images/querydsl-aliases.png)

We will start all the following queries at `EntityA` and first we will want the list of related
`EntityC` objects. We may approach it like this:

{title="Query with two-level implicit join", lang=java}
~~~
List<EntityC> result = new JPAQuery<>(em)
  .select(QEntityA.entityA.entityB.entityC)
  .from(QEntityA.entityA)
  .fetch();
~~~

This works and Hibernate generates the following SQL:

{title="Generated SQL (formatted)", lang=sql}
~~~
select
  entityc2_.id as id1_5_,
  entityc2_.entityD_id as entityD_3_5_,
  entityc2_.name as name2_5_
from
  EntityA entitya0_,
  EntityB entityb1_ inner join
  EntityC entityc2_ on entityb1_.entityC_id=entityc2_.id
where entitya0_.entityB_id=entityb1_.id
~~~

Effectively these are both inner joins and the result is as expected. But what happens if we
want to traverse to `EntityD`?

{title="Three-level implicit join", lang=java}
~~~
List<EntityD> result = new JPAQuery<>(em)
  .select(QEntityA.entityA.entityB.entityC.entityD)
  .from(QEntityA.entityA)
  .fetch();
~~~

After running this we end up with `NullPointerException` on the line with `select` method. What
happened? The core problem is that it is not feasible to generate infinitely deep path using
final fields. Querydsl offers some solutions to this as [discussed in the reference
documentation](http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/#d0e2260).
You can either ask the generator to initialize the path you need with the `@QueryInit` annotation
or you can mark the entity with `@Config(entityAccessors=true)` which generates accessor methods
instead of final fields. In the latter case you'd simply use this annotation on `EntityC` and
in the `select` call use `entityD()` which would create the property on the fly. This way you can
traverse relations ad lib. It requires some Querydsl annotations on the entities -- which you may
already use, for instance for custom constructors, etc.

However, instead of customizing the generation I'd advocate being explicit with the aliases.
If there is a join let it show! We can go around the limitation of max-two-level paths using just
a single join:

{title="Taming deep paths with a join", lang=java}
~~~
List<EntityD> result = new JPAQuery<>(em)
  .select(QEntityB.entityB.entityC.entityD)
  .from(QEntityA.entityA)
  .join(QEntityA.entityA.entityB, QEntityB.entityB)
  .fetch();
~~~

Here we lowered the nesting back to two levels by making `EntityB` explicit. We used existing
default alias `QEntityB.entityB`. This query makes the code run, but looks... unclean, really.
Let's go all the way and make all the joins explicit:

{title="Explicit joins with aliases", lang=java}
~~~
List<EntityD> result = new JPAQuery<>(em)
  .select(QEntityD.entityD)
  .from(QEntityA.entityA)
  // second parameter is alias for the path in the first parameter
  .join(QEntityA.entityA.entityB, QEntityB.entityB)
  // first parameter uses alias from the previous line
  .join(QEntityB.entityB.entityC, QEntityC.entityC)
  .join(QEntityC.entityC.entityD, QEntityD.entityD)
  .fetch();
~~~

Now this looks long, but it says exactly what it does -- no surprises. We may help it in a couple
of ways but the easiest one is to introduce the aliases upfront:

{title="Explicit upfront aliases", lang=java}
~~~
QEntityA a = new QEntityA("a");
QEntityB b = new QEntityB("b");
QEntityC c = new QEntityC("c");
QEntityD d = new QEntityD("d");
List<EntityD> result = new JPAQuery<>(em)
  .select(d)
  .from(a)
  .join(a.entityB, b)
  .join(b.entityC, c)
  .join(c.entityD, d)
  .fetch();
~~~

I like this most -- it is couple of lines longer but very clean and the query is very easy to read.
Anytime I work with joins I always go for explicit aliases.

Another related problem is joining the same entity more times (but in different roles). Newbie
programmers also often fall for a trap of using the same alias -- typically the default one offered
on each Q-class -- for multiple joins on the same entity. There can be two distinct local variables
representing these aliases but they both point to the same object instance -- hence it's still the
same alias. Whenever I join an entity more times in a query I always go for created aliases. When
I'm sure that an entity is in a query just once I may use default alias. It really pays off to
have a strict and clean strategy of how to use the aliases and local variables pointing at them.


## Functions and operations {#func-and-oper}

Let's see what data we will work on in the next sections so we can understand the returned results.

{title="Content of **Breed** table", width="narrow"}
| id | name |
|----|------|
| 1 | collie |
| 2 | german shepherd |
| 3 | retriever |

{title="Content of **Dog** table (id is not important)", width="narrow"}
| name | age | breed_id |
|------|-----|----------|
| Lassie | 7 | 1 (collie) |
| Rex | 6 | 2 (german shepherd) |
| Ben | 4 | 2 (german shepherd) |
| Mixer | 3 | `NULL` (unknown breed) |

The following examples can be found on GitHub in [FunctionsAndOperations.java](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/querydsl-basic/src/test/java/tests/FunctionsAndOperations.java).

When we want to write some operation we simply follow the fluent API. You can write `QDog.dog.age.`
and hit auto-complete -- this offers us all the possible operations and functions we can use on the
attribute. These are based on the known type of that attribute, so we only get the list of
functions that make sense (from technical point of view, not necessarily from business perspective,
of course).

This naturally makes sense for binary operations. If we want to see dog's age halved we can do it
like this:

~~~
List<Tuple> dogsGettingYounger = new JPAQuery<>(em)
  .select(QDog.dog.name, QDog.dog.age.divide(2))
  .from(QDog.dog)
  .fetch();
~~~

We will cover [Tuples](#querydsl-tuples) soon, now just know they can be printed easily and the
output would be `[[Lassie, 3], [Rex, 3], [Ben, 2], [Mixer (unknown breed), 1]]`. We are not limited
to constants and can add together two columns or multiply `amount` by `rate`, etc. You may also
integer results of the division -- this can be mended if you select `age` as double -- like this:

~~~
// rest is the same
.select(QDog.dog.name, QDog.dog.age.castToNum(Double.class).divide(2))
~~~

Unary functions are less natural as they are appended to the attribute expression just like
binary operations -- they just don't take any arguments:

~~~
List<Tuple> dogsAndNameLengths = new JPAQuery<>(em)
  .select(QDog.dog.name, QDog.dog.name.length())
  .from(QDog.dog)
  .fetch();
~~~

This returns `[[Lassie, 6], [Rex, 3], [Ben, 3], [Mixer (unknown breed), 21]]`. *JPA 2.1* allows
any function using the `FUNCTION` construct. We will cover this [later](#qdsl-function-template)
in the [advanced chapter](#ch-advanced-querydsl) on Querydsl.


### Aggregate functions {#querydsl-aggregation}

Using aggregate functions is the same like any other function -- but as we know from SQL, we need
to group by any other non-aggregated columns. For instance to see the counts of dogs for any
age we can write:

~~~
List<Tuple> dogCountByAge = new JPAQuery<>(em)
  .select(QDog.dog.age, QDog.dog.count())
  .from(QDog.dog)
  .groupBy(QDog.dog.age)
  .fetch();
~~~

Our example data have each dog with different age, so the results are boring.

If we want to see the average age of dogs per breed we use this:

~~~
List<Tuple> dogAvgAgeByBreed = new JPAQuery<>(em)
  .select(QBreed.breed.id, QBreed.breed.name, QDog.dog.age.avg())
  .from(QDog.dog)
  .leftJoin(QDog.dog.breed, QBreed.breed)
  .groupBy(QBreed.breed.id, QBreed.breed.name)
  .orderBy(QBreed.breed.name.asc())
  .fetch();
~~~

Because of `leftJoin` this returns also line `[null, null, 3.0]`. With `innerJoin` (or just `join`)
we would get only dogs with defined breed. On screen I'm probably interested in breed's name but
that relies on their uniqueness -- which may not be the case. To get the "true" results per breed
I added `breed.id` into the `select` clause. We can always display just names and if they are not
unique user will at least be curious about it. But that's beyond the discussion for now.

Querydsl supports `having` clause as well if the need arises. We also demonstrated `orderBy`
clause, just by the way, as it hardly deserves special treatment in this book.


## Subqueries {#querydsl-subqueries}

Here we will use the same data like in the previous section on functions and operations.
The following examples can be found on GitHub in [Subqueries.java](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/querydsl-basic/src/test/java/tests/Subqueries.java)).
You can also check Querydsl [reference documentation](http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/#d0e410).


### Independent subquery

If we want to find all the dogs that are of breed with a long name, we can do this:

{title="Dogs with a long breed name", lang=java}
~~~
List<Dog> dogsWithLongBreedName = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.breed.in(
    new JPAQuery<>() // no EM here
      .select(QBreed.breed)
      .from(QBreed.breed)
      // no fetch on subquery
      .where(QBreed.breed.name.length().goe(10))))
  .fetch();
~~~

This returns Ben and Rex, both german shepherds. Note that subquery looks like normal query, but
we don't provide `EntityManager` to it and we don't use any `fetch`. If you do the subquery will
be executed on its own first and its results will be fetched into `in` clause just as any other
collection would. This is not what we want in most cases -- especially when the code leads us to
an idea of a subquery. The previous result can be achieved with join as well -- and in such cases
joins are almost always preferable.

To make our life easier we can use `JPAExpressions.select(...)` instead of
`new JPAQuery().select(...)`. There is also a neat shortcut for the subquery with `select` and
`from` with the same expression.

~~~
JPAExpressions.selectFrom(QBreed.breed) ...
~~~

We will prefer using `JPAExpression` from now on. Another example finds average age of all dogs
and returns only those above it:

{title="Dogs older than average", lang=java}
~~~
List<Dog> dogsOlderThanAverage = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.age.gt(
    JPAExpressions.select(QDog.dog.age.avg())
      .from(QDog.dog)))
  .fetch();
~~~

This is perhaps on the edge regarding usage of the same alias `QDog.dog` for both inner and outer
query, but I dare to say it does not matter here. In both previous examples the same result can be
obtained when we execute the inner query first because it always provides the same result. What if
we need to drive some conditions of the inner query by the outer one?


### Correlated subquery

When we use object from the outer query in the subquery it is called *correlated subquery*. For
example, we want to know for what breeds we have no dogs:

{title="Breeds with no dogs", lang=java}
~~~
List<Breed> breedsWithoutDogs = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .where(
    JPAExpressions.selectFrom(QDog.dog)
      .where(QDog.dog.breed.eq(QBreed.breed))
      .notExists())
  .fetch();
~~~

We used a subquery with `exist/notExists` and we could omit `select`, although it can be used.
This returns a single breed -- *retriever*. Interesting aspect is that the inner query uses
something from the outer select (here `QBreed.breed`). Compared to the subqueries from the
previous section this one can have different result for each row of the outer query.

This one can actually be done by join, as well, but in this case I'd not recommend it. Depending on
the mapping you use, various things work on various providers. When you have `@ManyToOne Breed
breed` than this works on EclipseLink:

{title="Breeds with no dogs", lang=java}
~~~
List<Breed> result = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .leftJoin(QDog.dog).on(QBreed.breed.eq(QDog.dog.breed))
  .where(QDog.dog.isNull())
  // needed for isNotNull, not for isNull as those lines are unique
  .distinct()
  .fetch();
~~~

Alas, it fails on Hibernate (5.2.2) with `InvalidWithClauseException: with clause can only
reference columns in the driving table`. It seems to be an open bug mentioned in [this
StackOverflow answer](http://stackoverflow.com/a/26527967/658826) -- and the suggested solution
of using plain keys instead of objects indeed work (we'll elaborate on this in the next two
chapters):

~~~
// the rest is the same
.leftJoin(QDog.dog).on(QBreed.breed.id.eq(QDog.dog.breedId))
~~~

For this we need to switch `Breed breed` mapping to plain FK mapping, or use both of them with
one marked with updatable `false`:

~~~
@Column(name = "breed_id", updatable = false, insertable = false)
private Integer breedId;
~~~

Neither of the previous joins is *JPA 2.1* compliant as it uses entity join. There is, however,
another JPA query that works:

~~~
List<Breed> result = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .where(QBreed.breed.dogs.isEmpty())
  .fetch();
~~~

Internally this generates subquery with count or (not) exists anyway, there is no way around it.
But for this to work we also have to add the mapping to `Breed`:

~~~
@OneToMany(mappedBy = "breed")
private Set<Dog> dogs;
~~~

This may be rather superfluous for some cases (why should breed know the list of dogs?) but it
should not hurt. We somehow foreshadowed themes from the following chapters on various mapping
problems but we're not done with subqueries (or Querydsl) just yet. Let's now try to find dogs
that are older than average -- but this time for each breed:

{title="Dogs older than breed average", lang=java}
~~~
QDog innerDog = new QDog("innerDog");
List<Dog> dogsOlderThanBreedAverage = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.age.gt(
    JPAExpressions.select(innerDog.age.avg())
      .from(innerDog)
      .where(innerDog.breed.eq(QDog.dog.breed))))
  .fetch();
~~~

Notice the use of `innerDog` alias which is very important. Had you used `QDog.dog` in the subquery
it would have returned the same results like `dogsOlderThanAverage` above. This query returns only
Rex, because only german shepherds have more than a single dog -- and a single (or no) dog can't be
older than average.

This section is not about going deep into subquery theory (I'm not the right person for it in the
first place), but to demonstrate how easy and readable it is to write subqueries with Querydsl
API. We're still limited by JPQL, that means no subqueries in `from` or `select` clauses). When
writing subqueries be careful not to "reuse" alias from the outer query.


## Pagination

Very often we need to cut our results into smaller chunks, typically pages for some user interface,
but pagination is often used also with various APIs. To do it manually, we can simply specify
`offset` (what record is the first) and `limit` (how many records):

{title="Fetching a single page", lang=java}
~~~
List<Breed> breedsPageX = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .where(QBreed.breed.id.lt(17)) // random where
  .orderBy(QBreed.breed.name.asc())
  .offset((page - 1) * pageSize)
  .limit(pageSize)
  .fetch();
~~~

I used variables `page` (starting at one, hence the correction) and `pageSize` to calculate the
right values. Any time you paginate the results you want to use `orderBy` because SQL specification
does not guarantee any order without it. Sure, databases typically give you results in some natural
order (like "by ID"), but it is dangerous to rely on it.

Content of the page is good, but often we want to know total count of all the results. We use the
same query with the same conditions, we just first use `.fetchCount` like this:

{title="Fetching a single page and total count", lang=java}
~~~
JPAQuery<Breed> breedQuery = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .where(QBreed.breed.id.lt(17))
  .orderBy(QBreed.breed.name.asc());

long total = breedQuery.fetchCount();
List<Breed> breedsPageX = breedQuery
  .offset((page - 1) * pageSize)
  .limit(pageSize)
  .fetch();
~~~

We can even add `if` skipping the second query when count is 0 as we can just create an empty list.
And because this scenario is so typical Querydsl provides a shortcut for it:

{title="Pagination with Querydsl `fetchResults`", lang=java}
~~~
QueryResults<Breed> results = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .where(QBreed.breed.id.lt(17))
  .orderBy(QBreed.breed.name.asc())
  .offset((page - 1) * pageSize)
  .limit(pageSize)
  .fetchResults();
System.out.println("total count: " + results.getTotal());
System.out.println("results = " + results.getResults());
~~~

`QueryResults` wrap all the information we need for paginated result, including offset and limit.
It does not help us with reverse calculation of the `page` number from an `offset`, but I guess we
probably track the page number in some filter object anyway as we needed it as the input in the
first place.

And yes, it does not execute the second query when the count is zero.[^qdslpagexam]

[^qdslpagexam]: Example source code: https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/querydsl-basic/src/test/java/tests/Pagination.java


## Tuple results {#querydsl-tuples}

When you call `fetch()` the `List` is returned. When you call `fetchOne()` or `fetchFirst()` one
object is returned. The question is -- what type of object? This depends on the `select` clause
which can have a single parameter which determines the type or you can use list of expressions
for `select` in which case `Tuple` is returned. That is, a query with `select(QDog.dog)` will
return `Dog` (or `List<Dog>`) because `QDog.dog` is of type `QDog` that extends
`EntityPathBase<Dog>` which eventually implements `Expression<Dog>` -- hence the `Dog`.

But when you return multiple results we need to wrap them somehow. In JPA you will get `Object[]`
(array of objects) for each row. That works, but is not very convenient. Criteria API brings
`Tuple` for that reason which is much better. Querydsl uses `Tuple` idea as well. What's the deal?

{title="Tuples of attributes (columns)", lang=java}
~~~
List<Tuple> result = new JPAQuery<>(em)
  .select(QDog.dog.name, QBreed.breed.name)
  .from(QDog.dog)
  .join(QDog.dog.breed, QBreed.breed)
  .fetch();
result.forEach(t -> {
  String name = t.get(QDog.dog.name);
  String breed = t.get(1, String.class);
  System.out.println("Dog: " + name + " is " + breed);
});
~~~

As you can see in the `forEach` block we can extract columns by either using the expression that
was used in the `select` as well (here `QDog.dog.name`) or by index. Needless to say that the first
way is preferred. You can also extract the underlying array of objects using `toArray()`.

Because `Tuple` works with any expression we can use the whole entities too:

{title="Tuples of entities", lang=java}
~~~
List<Tuple> result = new JPAQuery<>(em)
  .select(QDog.dog, QBreed.breed)
  .from(QDog.dog)
  .join(QDog.dog.breed, QBreed.breed)
  .fetch();
result.forEach(t -> {
  Dog dog = t.get(QDog.dog);
  Breed breed = t.get(QBreed.breed);
  System.out.println("\nDog: " + dog);
  System.out.println("Breed: " + breed);
});
~~~

And of course, you can combine entities with columns ad-lib.

There are other ways how to combine multiple expressions into one object. See the reference guide
to see how to [populate beans](http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/#d0e2187),
or how to use [projection constructors](http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/#d0e2198).


## Fetching *to-many* eagerly

In the following example we select all the breeds and we want to print the collection of the dogs
of that breed:

{title="Naive approach to *to-many*", lang=java}
~~~
// mapping on Breed
@OneToMany(mappedBy = "breed")
private Set<Dog> dogs;

// query
List<Breed> breed = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .fetch();
breed.forEach(b ->
  System.out.println(b.toString() + ": " + b.getDogs()));
~~~

This executes three queries. First the one that is obvious and then one for each breed when you
want to print the dogs. Actually, for EclipseLink it does not produce the other queries and merely
prints `{IndirectSet: not instantiated}` instead of the collection content. You can nudge
EclipseLink with something like `b.getDogs().size()` or other meaningful collection operation.
It seems `toString()` isn't meaningful enough for EclipseLink.

W> While writing this example I got a really hard time to make it act consistently for both
W> Hibernate and EclipseLink and even to make it load those dogs at all. This was caused
W> by using the same `EntityManager` I used for data preparation (although it was after commit).
W> I had to clear (or reopen) the entity manager and also evict the second-level cache for
W> EclipseLink (Hibernate doesn't use it out of the box).

We can force the eager fetch when we adjust the mapping:

~~~
@OneToMany(mappedBy = "breed", fetch = FetchType.EAGER)
private Set<Dog> dogs;
~~~

However, while the fetch is eager, EclipseLink still does it with three queries (1+N in general).
Hibernate uses one query with join. So yes, it is eager, but not necessarily efficient. There is
a potential problem with paging when using join to *to-many* -- the problem [we mentioned
already](#cant-escape-sql) and we'll return to it [later](#to-many-paginating). What happens when
we add `offset` and `limit`?

~~~
List<Breed> breeds = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .offset(1)
  .limit(1)
  .fetch();
~~~

Because EclipseLink uses separate query for breeds, nothing changes and we get the second result
(by the way, we forgot to order it!). Hibernate is smart enough to use separate query too, as soon
as it smells the offset/limit combo. It makes sense, because query says "gimme breeds!" -- although
not everything in JPA is always free of surprises. In any case, eager collection is not recommended.
There may be notable exceptions -- maybe some embeddables or other really primitive collections --
but I'd never risk fetching collection of another entities as it asks for fetching the whole
database eventually.

What if we write a query that joins breed and dogs ourselves? We assuming no pagination again.

~~~
List<Breed> breeds = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .join(QBreed.breed.dogs, QDog.dog)
  .distinct()
  .fetch();
breeds.forEach(b ->
  System.out.println(b.toString() + ": " + b.getDogs()));
~~~

If you check the logs queries are indeed generated with joins, but it is not enough. EclipseLink
still prints uninitialized indirect list (and relevant operation would trigger the select),
Hibernate prints it nicely, but needs additional N selects as well. We need to say what collection
we want initialized explicitly using `fetchJoin` like so:

{title="Fetch join", lang=java}
~~~
List<Breed> breeds = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .join(QBreed.breed.dogs).fetchJoin()
  .distinct()
  .fetch();
~~~

You use `fetchJoin()` just after the `join` with a collection path and in this case you don't
need to use second parameter with alias, unless you want to use it in `where` or `select`, etc.[^fjall]

[^fjall]: There is also Hibernate specific `fetchAll()` that loads lazy single-valued properties,
    but this is beyond JPA specification.


Because we used `join` with *to-many* relations ourselves JPA assumes we want all the results
(5 with our demo data [defined previously](#querydsl-aggregation)). That's why we also added
`distinct()` -- this ensures we get only unique results from the `select` clause. But these unique
results will still have their collections initialized because SQL still returns 5 results and
JPA "distincts" it in post-process. This means we cannot paginate queries with joins, `distinct`
or not. This is something we will tackle in a [dedicated section](#to-many-paginating).


## Querydsl and code style

Querydsl is a nice API and DSL but may lead to horrific monsters like:

~~~
new JPAQuery(em)
  .select(QClientAgreementBankAccountTransaction.clientAgreementBankAccountTransaction.transactionId))
  .from(QClientAgreement.clientAgreement)
  .join(QClientAgreementBankAccount.clientAgreementBankAccount).on(
    QClientAgreementBankAccount.clientAgreementBankAccount.clientAgreementId
      .eq(QClientAgreement.clientAgreement.id))
  .join(QClientAgreementBankAccountTransaction.clientAgreementBankAccountTransaction).on(
    QClientAgreementBankAccountTransaction.clientAgreementBankAccountTransaction.clientAgreementBankAccountId
      .eq(QClientAgreementBankAccount.clientAgreementBankAccount.id))
  .where(QClientAgreement.clientAgreement.id.in(clientAgreementsToDelete))
  .fetch();
~~~

The problems here are caused by long entity class names but often there is nothing you can about
it. Querydsl exacerbates it with the duplication of the name in `QClassName.className`. There are
many ways how to tackle the problem.

We can introduce local variables, even with very short names as they are very close to the
query itself. In most queries I saw usage of acronym aliases, like `cabat` for
`QClientAgreementBankAccountTransaction`. This clears up the query significantly, especially when
the same alias is repeated many times:

~~~
QClientAgreement ca = QClientAgreement.clientAgreement;
QClientAgreementBankAccount caba =
  QClientAgreementBankAccount.clientAgreementBankAccount;
QClientAgreementBankAccountTransaction cabat =
  QClientAgreementBankAccountTransaction.clientAgreementBankAccountTransaction;
new JPAQuery(em)
  .select(cabat.transactionId)
  .from(ca)
  .join(caba).on(caba.clientAgreementId.eq(ca.id))
  .join(cabat).on(cabat.clientAgreementBankAccountId.eq(caba.id))
  .where(ca.id.in(clientAgreementsToDelete))
  .fetch();
~~~

You give up some explicitness in the query with those acronyms but you get much higher
signal-to-noise ratio which can easily overweight the burden of mental mapping to local variables.

Another option is to use static imports which halves the QNames into half:

~~~
new JPAQuery(em)
  .select(clientAgreementBankAccountTransaction.transactionId)
  .from(clientAgreement)
  .join(clientAgreementBankAccount).on(
    clientAgreementBankAccount.clientAgreementId.eq(clientAgreement.id))
  .join(clientAgreementBankAccountTransaction).on(
    clientAgreementBankAccountTransaction.clientAgreementBankAccountId
      .eq(clientAgreementBankAccount.id))
  .where(clientAgreement.id.in(clientAgreementsToDelete))
  .fetch()
~~~

This is clearly somewhere between the first (totally unacceptable) version and the second where
the query was very brief at the cost of using acronyms for aliases. Using static names is great
when they don't collide with anything else. But while `QDog` itself says clearly it is metadata
type, name of its static field `dog` clearly collides with any dog variable of a real `Dog` type
you may have in your code. Still, we use static imports extensively in various infrastructural
code where no confusion is possible.

We also often use field or variable named `$` that represents the root of our query. I never ever
use that name for anything else and long-term experiments showed that it brought no confusion into
our team whatsoever. Snippet of our DAO class may look like this:

~~~
public class ClientDao {
	public static final QClient $ = QClient.client;

	public Client findByName(String name) {
 		return queryFrom($) // our shortcut for new/select/from
 			.where($.name.eq(name))
 			.fetchOne($);
	}

	public List<Client> listByRole(ClientRole clientRole) {
		return queryFrom($)
			.where($.roles.any().eq(clientRole))
			.list($);
	}
...
~~~

As a bonus you can see how `any()` is used on collection path `$.roles`. You can even go on
to a specific property -- for instance with our demo data we can obtain list of breeds where any
dog is named Rex like this:

~~~
List<Breed> breedsWithRex = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .where(QBreed.breed.dogs.any().name.eq("Rex"))
  .fetch();
~~~

This produces SQL with `EXISTS` subquery although the same can be written with `join`
and `distinct`.


## More

That's it for our first tour around Querydsl. We will see more in the chapter on more [advanced
features](#ch-advanced-querydsl) (or perhaps just features used less). In the course of this
chapter there was plenty of links to other resources too -- let's sum it up:

* [Querydsl Reference Guide](http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/)
is the first stop when you want to learn more. It is not the last stop though, as it does not even
cover all the stuff from this chapter. It still is a useful piece of documentation.
* Querydsl is also popular enough on [StackOverflow](http://stackoverflow.com/questions/tagged/querydsl)
with Timo Westkämper himself often answering the questions.
* Finally there is their [mailing-list](https://groups.google.com/forum/#!forum/querydsl)
(`querydsl@googlegroups.com`) -- with daily activity where you get what you need.

For an introduction you can also check [this slide
deck](http://www.slideshare.net/timowestkamper/querydsl-overview-2014) that covers older version 3,
but except for the fluent API changes the concept is the same.